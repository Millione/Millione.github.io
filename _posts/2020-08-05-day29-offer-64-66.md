---
layout:     post
title:      "DAY29-剑指Offer64-66"
subtitle:   " \"位运算、数组\""
date:       2020-08-05 12:00:00
author:     "LiuJ"
header-img: "img/post-bg-algorithm.jpg"
catalog: true
tags:
    - 刷题
---

## [64-求1+2+...+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

### 1. 题意

求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

### 2. 思路

递归求解，并使用短路操作终止递归。

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 3. 代码

#### cpp

```cpp
class Solution {
public:
    int sumNums(int n) {
        n && (n += sumNums(n - 1));
        return n;
    }
};
```

#### java

```java
class Solution {
    public int sumNums(int n) {
        boolean flag = n != 0 && ((n += sumNums(n - 1)) != 0);
        return n;
    }
}
```

#### python

```python
class Solution:
    def __init__(self):
        self.res = 0
    def sumNums(self, n: int) -> int:
        n > 1 and self.sumNums(n - 1)
        self.res += n
        return self.res
```

## [65-不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

### 1. 题意

写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

### 2. 思路

位运算。两数相加，不考虑进位的情况下等同于相异或，进位值等同于相与再左移一位。

- 时间复杂度：$O(1)$。
- 空间复杂度：$O(1)$。

### 3. 代码

#### cpp

```cpp
class Solution {
public:
    int add(int a, int b) {
        int x = ~(1 << 31);
        while (b != 0) {
            int c = (a & b & x) << 1;
            a ^= b;
            b = c;
        }
        return a;
    }
};
```

#### java

```java
class Solution {
    public int add(int a, int b) {
        while (b != 0) {
            int c = (a & b) << 1;
            a ^= b;
            b = c;
        }
        return a;
    }
}
```

#### python

```python
class Solution:
    def add(self, a: int, b: int) -> int:
        x = 0xffffffff
        a, b = a & x, b & x
        while b != 0:
            a, b = (a ^ b), (a & b) << 1 & x
        return a if a <= 0x7fffffff else ~(a ^ x)
```

## [66-构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

### 1. 题意

给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

### 2. 思路

利用对称关系，左乘一遍，再右乘一遍即可。

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 3. 代码

#### cpp

```cpp
class Solution {
public:
    vector<int> constructArr(vector<int>& a) {
        int n = a.size();
        vector<int> b(n, 1);
        for (int i = 1; i < n; i++) {
            b[i] = a[i - 1] * b[i - 1];
        }
        int tmp = 1;
        for (int i = n - 2; i >= 0; i--) {
            tmp *= a[i + 1];
            b[i] *= tmp;
        }
        return b;
    }
};
```

#### java

```java
class Solution {
    public int[] constructArr(int[] a) {
        int n = a.length;
        if (n == 0) {
            return a;
        }
        int[] b = new int[n];
        b[0] = 1;
        for (int i = 1; i < n; i++) {
            b[i] = b[i - 1] * a[i - 1];
        }
        int tmp = 1;
        for (int i = n - 2; i >= 0; i--) {
            tmp *= a[i + 1];
            b[i] *= tmp;
        }
        return b;
    }
}
```

#### python

```python
class Solution:
    def constructArr(self, a: List[int]) -> List[int]:
        b, tmp = [1] * len(a), 1
        for i in range(1, len(a)):
            b[i] = b[i - 1] * a[i - 1]
        for i in range(len(a) - 2, -1, -1): 
            tmp *= a[i + 1]
            b[i] *= tmp
        return b
```

