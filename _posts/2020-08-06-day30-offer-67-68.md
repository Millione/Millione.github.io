---
layout:     post
title:      "DAY30-剑指Offer67-68"
subtitle:   " \"字符串、二叉树\""
date:       2020-08-06 12:00:00
author:     "LiuJ"
header-img: "img/post-bg-algorithm.jpg"
catalog: true
tags:
    - 刷题
---

## [67-把字符串转换成整数](https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)

### 1. 题意

写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。

### 2. 思路

字符串模拟，注意边界溢出情况。

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(1)$。

### 3. 代码

#### cpp

```cpp
class Solution {
public:
    int strToInt(string str) {
        int i = 0, flag = 1;
        long res = 0;
        while (str[i] == ' ') {
            i++;
        }
        if (str[i] == '-') {
            flag = -1;
        }
        if (str[i] == '-' || str[i] == '+') {
            i++;
        }
        for (; i < str.size() && isdigit(str[i]); i++)  {
            res = res * 10 + (str[i] - '0');
            if (res >= INT_MAX && flag == 1) {
                return INT_MAX;
            }
            if (res > INT_MAX && flag == -1) {
                return INT_MIN;
            }
        } 
        return flag * res;
    }
};
```

#### java

```java
class Solution {
    public int strToInt(String str) {
        str = str.trim();
        if (str == null || str.length() == 0) {
            return 0;
        }
        boolean positive = true;
        int i = 0;
        if (str.charAt(i) == '+') {
            i++;
        } else if (str.charAt(i) == '-') {
            i++;
            positive = false;
        }
        int ans = 0;
        for (; i < str.length(); i++) {
            int num = str.charAt(i) - '0';
            if (num < 0 || num > 9) {
                break;
            }
            
            if (positive) {
                if (ans > Integer.MAX_VALUE / 10 || ans == Integer.MAX_VALUE / 10 && num > Integer.MAX_VALUE % 10) {
                    return Integer.MAX_VALUE;
                }
                ans = ans * 10 + num;
            } else {
                if (ans < Integer.MIN_VALUE / 10 || ans == Integer.MIN_VALUE / 10 && -num < Integer.MIN_VALUE % 10) {
                    return Integer.MIN_VALUE;
                }
                ans = ans * 10 - num;
            }
        }
        return ans;
    }
}
```

#### python

```python
class Solution:
    def strToInt(self, str: str) -> int:
        str = str.strip()
        if not str: 
            return 0
        res, i, sign = 0, 1, 1
        int_max, int_min, bndry = 2 ** 31 - 1, -2 ** 31, 2 ** 31 // 10
        if str[0] == '-': 
            sign = -1
        elif str[0] != '+': 
            i = 0
        for c in str[i:]:
            if not '0' <= c <= '9': 
                break
            if res > bndry or res == bndry and c > '7':
                return int_max if sign == 1 else int_min
            res = 10 * res + ord(c) - ord('0')
        return sign * res
```

## [68I-二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

### 1. 题意

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

### 2. 思路

判断 p, q 结点位于根结点的左侧还是右侧，若根结点即为 p 或 q 结点，直接返回；若都在左侧，向左侧遍历。若都在右侧，向右侧遍历。若一左一右，返回根结点即可。

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(1)$。

### 3. 代码

#### cpp

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while (root != nullptr) {
            if (root->val > p->val && root->val > q->val) {
                root = root->left;
            } else if (root->val < p->val && root->val < q->val) {
                root = root->right;
            } else {
                break;
            }
        }
        return root;
    }
};
```

#### java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while (root != null) {
            if (root.val > p.val && root.val > q.val) {
                root = root.left;
            } else if (root.val < p.val && root.val < q.val) {
                root = root.right;
            } else {
                break;
            }
        }
        return root;
    }
}
```

#### python

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        while root:
            if root.val > p.val and root.val > q.val:
                root = root.left;
            elif root.val < p.val and root.val < q.val:
                root = root.right
            else:
                break;
        return root;
```

## [68II-二叉树的最近公共祖先](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

### 1. 题意

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

### 2. 思路

递归。

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 3. 代码

#### cpp

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) {
            return root;
        }
        if (root->val == p->val || root->val == q->val) {
            return root;
        }
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left == nullptr) {
            return right;
        }
        if (right == nullptr) {
            return left;
        }
        return root;
    }
};
```

#### java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) {
            return root;
        }
        if (root.val == p.val || root.val == q.val) {
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left == null) {
            return right;
        }
        if (right == null) {
            return left;
        }
        return root;
    }
}
```

#### python

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        if not root or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if not left:
            return right
        if not right:
            return left
        return root

```

